head(main)
main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "code")
main.melt <- melt(main[,c(1,3:7)], id.vars = "Food.code", variable.name = "Level", value.name = "code")
main.melt <- melt(main[,c(1,3:7)], id.vars = "Food.code", variable.name = "Level")
class(main[1:1])
class(main[1,1])
class(main[1,4])
??read.table
?read.table
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, substr(main$Food.code, 1, i))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- cbind(main,split.foodcodes)
main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "code")
head(main)
class(main[1,4])
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- data.frame(split.foodcodes, substr(main$Food.code, 1, i), stringsAsFactors=F)    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- cbind(main,split.foodcodes)
substr(main$Food.code, 1, i)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- data.frame(matrix(vector(), 0, num.levels,                dimnames=list(c(), paste0("L",1:num.levels))),                stringsAsFactors=F)    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, substr(main$Food.code, 1, i), stringsAsFactors=F)
cbind(NULL,1:10)
data.frame(NULL,1:10)
split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))
split.foodcodes
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    main <- data.frame(main,split.foodcodes,stringsAsFactors=F)
head(main)
class(main[1,5])
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(main[,1],split.foodcodes,stringsAsFactors=F)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(Food.code=main[,1],split.foodcodes,stringsAsFactors=F)
main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "code")
head(main.melt)
class(main.melt[,1])
class(main.melt[,2])
class(main.melt[,3])
main.merge <- merge(main.melt, nodes, by = "Food.code")
head(main.merge)
head(nodes$Food.code)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(Food.code=main[,1],split.foodcodes,stringsAsFactors=F)    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")
head(nodes)
nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")
head(nodes)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # fix node column names    colnames(nodes) <- c("Food.code","Main.food.description")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(Food.code=main[,1],split.foodcodes,stringsAsFactors=F)    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")
head(nodes)
nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")
head(nodes)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(Food.code=main[,1],split.foodcodes,stringsAsFactors=F)    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")
head(main.merge)
main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")
head(main.cast)
main.cast[is.na(main.cast)] <- ""    main.levels <- colnames(main.cast)    main.cast <- sapply(main.levels, function(colname) paste(colname, main.cast[,colname], sep="_"))
head(main.cast)
colnames(main.cast)[-1]
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(Food.code=main[,1],split.foodcodes,stringsAsFactors=F)    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))
head(main.cast)
head(pathstring)
head(main)
?paste
head(paste(main[,colnames(split.foodcodes)], collapse="/"))
head(main[,colnames(split.foodcodes)])
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(main,split.foodcodes,stringsAsFactors=F)
head(main)
apply(main, 1, function(xx) paste(xx[3:7],collapse="/"))
head(main)
apply(main, 1, function(xx) paste("foodcode", xx[3:7], xx[2], collapse="/"))
head(apply(main, 1, function(xx) paste("foodcode", xx[3:7], xx[2], collapse="/")))
head(apply(main, 1, function(xx) paste("foodcode", xx[3:7], xx[2]2:1, collapse="/")))
2:1
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    main[,"pathstring"] <- apply(main, 1, paste("foodcode", paste(main[,1:(num.levels+1)], collapse="/"), sep="/"))
head(main)
x <- apply(main, 1, paste("foodcode", paste(main[,1:(num.levels+1)], collapse="/"), sep="/"))
x <- apply(main, 1, function(xx) paste(xx[,1:(num.levels+1)], collapse="/"))
x <- apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/"))
head(x)
x <- apply(main, 1, function(xx) paste("foodcode", xx[1:(num.levels+1)], collapse="/"))
head(x)
x <- apply(main, 1, function(xx) paste("foodcode", xx[1:(num.levels+1)], collapse="/"), sep="/")
x <- apply(main, 1, function(xx) paste("foodcode", xx[1:(num.levels+1)], collapse="/", sep="/"))
head(x)
pathstring <- paste("foodcode", apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/")), sep="/")
head(pathstring)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))#    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    pathstring <- paste("foodcode", apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/")), sep="/")#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))
head(main.cast)
main.join <- left_join(main.cast, pathstring, by = "Food.code") %>%                 mutate(pathString = paste("foodcode", L1.x, L2.x, L3.x, L4.x, L5.x, Description, sep = "/"),                         taxonomy = paste(L1.x, L2.x, L3.x, L4.x, L5.x, Description, sep = ";"))
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    main["pathstring"] <- paste("foodcode", apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/")), sep="/")#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))
head(main.cast)
head(main.melt)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    main["pathstring"] <- paste("foodcode", apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/")), sep="/")#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")
head(main.cast)
head(main)
main.join <- merge(main.cast, main[,c("Food.code","Main.food.description","pathstring")], by="Food.code")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    main["pathstring"] <- paste("foodcode", apply(main, 1, function(xx) paste(xx[1:(num.levels+1)], collapse="/")), sep="/")#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description","pathstring")], by="Food.code")
head(main.join)
foodTree <- as.Node(main.join, pathName = "pathString")
?as.Node
foodTree <- as.Node(main.join, pathName = "pathstring")
tree <- recursiveNewickWrite(foodTree)
cat(tree, file="pj.test.tree.txt")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description","pathstring")], by="Food.code")
main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")
head(main.join)
main.join["newickstring"] <- paste("foodcode", apply(main, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    main.join["taxonomy"] <- apply(main, 1, function(xx) paste(xx[-1], collapse=";"))
head(main.join)
main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")    main.join["newickstring"] <- paste("foodcode", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    main.join["taxonomy"] <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))
head(main.join)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")    newickstring <- paste("foodcode", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    main.join <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
head(main.join)
foodTree <- as.Node(main.join, pathName = "pathstring")    tree <- recursiveNewickWrite(foodTree)
foodTree <- as.Node(main.join, pathName = "newickstring")
tree <- recursiveNewickWrite(foodTree)
cat(tree, file="pj.test.tree.txt")
addl_foods_fn
addl_foods_fn <- c("data/Soylent_codes.txt", "data/MCTs_study_missing_variables.txt")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")    newickstring <- paste("foodcode", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    main.join <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)    # Export the the main join file    #### Make the foodTree environment####    foodTree <- as.Node(main.join, pathName = "newickstring")    tree <- recursiveNewickWrite(foodTree)
head(addl.foods)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    num.levels <- 5 #for now    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(split.foodcodes, main[,2:1], stringsAsFactors=F)#
    # melt the data    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    # merge to get the names    main.merge <- merge(main.melt, nodes, by = "Level.code")    # reform into original shape    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # replace NAs with empty strings for easier name creation    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")    newickstring <- paste("foodcode", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    main.join <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)    # Export the the main join file    #### Make the foodTree environment####    foodTree <- as.Node(main.join, pathName = "newickstring")    tree <- recursiveNewickWrite(foodTree)
cat(tree, file="pj.test.tree.txt")
head(main.join)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    split.foodcodes <- NULL    for(i in 1:num.levels)        split.foodcodes <- cbind(split.foodcodes, I(substr(main$Food.code, 1, i)))    colnames(split.foodcodes) <- paste0("L",1:num.levels)    main <- data.frame(main, split.foodcodes, stringsAsFactors=F)#
    # melt the data, merge to get the node names, then cast back    main.melt <- melt(main, id.vars = "Food.code", variable.name = "Level", value.name = "Level.code")    main.merge <- merge(main.melt, nodes, by = "Level.code")    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # prepend level to all level descriptions    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    # merge back with original table to grab Food Description    main.join <- merge(main.cast, main[,c("Food.code","Main.food.description")], by="Food.code")
head(main.join)
output_taxonomy_fn <- "pj.taxonomy.txt"
export <- final.table %>% select(Food.code, taxonomy, Main.food.description)    export$Main.food.description <- gsub("_", " ", export$Main.food.description)    write.table(export, output_taxonomy_fn, sep = "\t", quote = FALSE, row.names = FALSE)
final.table <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
export <- final.table %>% select(Food.code, taxonomy, Main.food.description)    export$Main.food.description <- gsub("_", " ", export$Main.food.description)    write.table(export, output_taxonomy_fn, sep = "\t", quote = FALSE, row.names = FALSE)
food_database_fn <- "data/SuperTrackerDatabase.txt"
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character")
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="")
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="")
head(main)
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="")
head(main)
gsub("[^[:alnum] ]", "", main[1,3])
gsub("[^[:alnum:] ]", "", main[1,3])
gsub("[^[:alnum: ] ]", "", main[1,3])
gsub("[^[:alnum:]]", "", main[1,3])
gsub("[^[:alnum:]]", "_", main[1,3])
gsub("[^[:alnum:]*]", "_", main[1,3])
gsub("[^[:alnum:]+]", "_", main[1,3])
gsub("[^[:alnum:]]+", "_", main[1,3])
gsub("[^[:alnum:]]+", "_", main[1:5,3])
gsub("[^[:alnum:]]+", "_", main[1:10,3])
main[1:10,3]
?read.table
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)
gsub("[^[:alnum:]]+", "_", main[1:10,3])
main[1:10,]
duplicated(main[1:10,])
duplicated(main[1:10,1])
raw_database_fn <- "data/IMP/CompleteSuperTrackerDatabase.txt"
output_fn <- "data/IMP/SuperTrackerDatabase.txt"
main <- read.table(raw_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    # replace anything that isn't a number or character with an underscore (format for QIIME)    main$Main.food.description <- gsub("[^[:alnum:]]+", "_", main$Main.food.description)#
    # make a new food id that also uses the mod.code     main$FoodID <- paste(main$Food.code, main$Mod.code, sep=".")    # grab the first occurence of any food id and we'll use that to construct the tree     # note that SuperTracker has duplicate names for each Food ID (important for mapping, but not for the actual tree)    main <- main[!duplicated(FoodID),]#
    write.table(main[, c("FoodID", "Main.food.description")], output_fn, sep = "\t", quote = FALSE, row.names = FALSE)
main <- read.table(raw_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    # replace anything that isn't a number or character with an underscore (format for QIIME)    main$Main.food.description <- gsub("[^[:alnum:]]+", "_", main$Main.food.description)#
    # make a new food id that also uses the mod.code     main$FoodID <- paste(main$Food.code, main$Mod.code, sep=".")    # grab the first occurence of any food id and we'll use that to construct the tree     # note that SuperTracker has duplicate names for each Food ID (important for mapping, but not for the actual tree)    main <- main[!duplicated(main$FoodID),]#
    write.table(main[, c("FoodID", "Main.food.description")], output_fn, sep = "\t", quote = FALSE, row.names = FALSE)
head(main)
main <- read.table(raw_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    main$Old.Main.food.description <- main$Main.food.description    # replace anything that isn't a number or character with an underscore (format for QIIME)    main$Main.food.description <- gsub("[^[:alnum:]]+", "_", main$Main.food.description)#
    # make a new food id that also uses the mod.code     main$FoodID <- paste(main$Food.code, main$Mod.code, sep=".")    # grab the first occurence of any food id and we'll use that to construct the tree     # note that SuperTracker has duplicate names for each Food ID (important for mapping, but not for the actual tree)    main <- main[!duplicated(main$FoodID),]    # write everything out so that we have it for reference    write.table(main, output_fn, sep = "\t", quote = FALSE, row.names = FALSE)
head(main)
nodes_fn="data/NodeLabels.txt"; food_database_fn="data/IMP/SuperTrackerDatabase.txt"; addl_foods_fn=c("data/Soylent_codes.txt";"data/MCTs_study_missing_variables.txt"); output_tree_fn="test.tree.txt"; output_taxonomy_fn = "test.taxonomy.txt"
nodes_fn="data/NodeLabels.txt"; food_database_fn="data/IMP/SuperTrackerDatabase.txt"; addl_foods_fn=c("data/Soylent_codes.txt","data/MCTs_study_missing_variables.txt"); output_tree_fn="test.tree.txt"; output_taxonomy_fn = "test.taxonomy.txt"
main <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")
head(main)
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]    # add additional food codes    for(i in 1:length(addl_foods_fn))    {        addl.foods <- read.table(addl_foods_fn[i], header=T, sep="\t", colClasses="character")        main <- rbind(main, addl.foods)            }#
    flevels <- NULL    for(i in 1:num.levels)        flevels <- cbind(flevels, I(substr(main$FoodID, 1, i)))    colnames(flevels) <- paste0("L",1:num.levels)    main <- data.frame(main, flevels, stringsAsFactors=F)#
    # melt the data, merge to get the node names, then cast back    main.melt <- melt(main, id.vars = "FoodID", variable.name = "Level", value.name = "Level.code")    main.merge <- merge(main.melt, nodes, by = "Level.code")    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # prepend level to all level descriptions    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    # merge back with original table to grab Food Description    main.join <- merge(main.cast, main[,c("FoodID","Main.food.description")], by="FoodID")    # create a proper newick string for the tree    newickstring <- paste("foodtreeroot", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    # create a proper taxonomy string for QIIME    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    final.table <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]
flevels <- NULL    for(i in 1:num.levels)        flevels <- cbind(flevels, I(substr(main$FoodID, 1, i)))    colnames(flevels) <- paste0("L",1:num.levels)    main <- data.frame(main, flevels, stringsAsFactors=F)#
    # melt the data, merge to get the node names, then cast back    main.melt <- melt(main, id.vars = "FoodID", variable.name = "Level", value.name = "Level.code")    main.merge <- merge(main.melt, nodes, by = "Level.code")    main.cast <- dcast(main.merge, Food.code ~ Level, value.var = "Main.food.description")    # prepend level to all level descriptions    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    # merge back with original table to grab Food Description    main.join <- merge(main.cast, main[,c("FoodID","Main.food.description")], by="FoodID")    # create a proper newick string for the tree    newickstring <- paste("foodtreeroot", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    # create a proper taxonomy string for QIIME    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    final.table <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]
flevels <- NULL    for(i in 1:num.levels)        flevels <- cbind(flevels, I(substr(main$FoodID, 1, i)))    colnames(flevels) <- paste0("L",1:num.levels)    main <- data.frame(main, flevels, stringsAsFactors=F)#
    # melt the data, merge to get the node names, then cast back    main.melt <- melt(main, id.vars = "FoodID", variable.name = "Level", value.name = "Level.code")    main.merge <- merge(main.melt, nodes, by = "Level.code")    main.cast <- dcast(main.merge, FoodID ~ Level, value.var = "Main.food.description")    # prepend level to all level descriptions    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    # merge back with original table to grab Food Description    main.join <- merge(main.cast, main[,c("FoodID","Main.food.description")], by="FoodID")    # create a proper newick string for the tree    newickstring <- paste("foodtreeroot", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    # create a proper taxonomy string for QIIME    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    final.table <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
head(final.table)
which(final.table$Main.food.description=="Fruit_smoothie_made_with_whole_milk")
final.table[final.table$Main.food.description=="Fruit_smoothie_made_with_whole_milk",]
final.table[126:130,]
length(NULL)
FT_FOLDER <- ""/Users/pvangay/Dropbox/UMN/KnightsLab/Food_Tree/R"
FT_FOLDER <- "/Users/pvangay/Dropbox/UMN/KnightsLab/Food_Tree/R"
head(final.table)
!(main$FoodID %in% final.table$FoodID)
sum(!(main$FoodID %in% final.table$FoodID))
!(final.table$FoodID %in% main$FoodID)
sum(!(final.table$FoodID %in% main$FoodID))
!(1:11 %in% 1:10)
sum(!(1:11 %in% 1:10))
sum(!(1:10 %in% 1:11))
which(!(main$FoodID %in% final.table$FoodID))
check.missing.foods <- function(food_database_fn, food_records_fn, output_fn){    fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    diet <- read.table(food_records_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)#
    diet$FoodID <- paste(diet$Food.code, diet$Mod.code, sep=".")    write.table(diet[!(diet$FoodID %in% fdata$FoodID), ], output_fn, sep = "\t", quote = FALSE, row.names = FALSE)}
check.missing.foods(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")
check.missing.foods(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")
check.missing.foods <- function(food_database_fn, food_records_fn, output_fn){    fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    diet <- read.table(food_records_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)#
    diet$FoodID <- paste(diet$Food.code, diet$Mod.code, sep=".")    foods.missing <- unique(diet[!(diet$FoodID %in% fdata$FoodID), "Main.food.description"])#
    write.table(foods.missing, output_fn, sep = "\t", quote = FALSE, row.names = FALSE)}
check.missing.foods(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")
check.missing.foods(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")
format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes.txt","data/MCT/MCTs_study_missing_variables.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
FT_FOLDER <- "/Users/pvangay/Dropbox/UMN/KnightsLab/Food_Tree/R"
source(paste0(FT_FOLDER,"lib/newick.tree.r"))source(paste0(FT_FOLDER,"lib/check.food.db.r"))source(paste0(FT_FOLDER,"lib/format.food.db.r"))source(paste0(FT_FOLDER,"lib/make.food.tree.r"))
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))
format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes.txt","data/MCT/MCTs_study_missing_variables.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
colnames(main)
colnames(main) == "mod"
sum(colnames(main) == "mod")
FT_FOLDER <- "/Users/pvangay/Dropbox/UMN/KnightsLab/Food_Tree/R"source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")format.food.db(raw_database_fn="data/MCT/MCTs_study_missing_variables.txt", output_fn="data/MCT/MCTs_study_missing_variables_formatted.txt")format.food.db(raw_database_fn="data/MCT/Soylent_codes.txt", output_fn="data/MCT/Soylent_codes_formatted.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
format.food.db(raw_database_fn="data/IMP/CompleteSuperTrackerDatabase.txt", output_fn="data/IMP/SuperTrackerDatabase.txt")check.food.db(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt",     addl_foods_fn=NULL, output_tree_fn="output/supertracker.tree.txt",     output_taxonomy_fn = "output/supertracker.taxonomy.txt")#
# make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt", #     addl_foods_fn=c("data/Soylent_codes.txt","data/MCTs_study_missing_variables.txt"), output_tree_fn="test.tree.txt", #     output_taxonomy_fn = "test.taxonomy.txt")
addl_foods_fn=NULL
length(addl_foods_fn)
source(paste0(FT_FOLDER,"lib/newick.tree.r"))source(paste0(FT_FOLDER,"lib/check.food.db.r"))source(paste0(FT_FOLDER,"lib/format.food.db.r"))source(paste0(FT_FOLDER,"lib/make.food.tree.r"))format.food.db(raw_database_fn="data/IMP/CompleteSuperTrackerDatabase.txt", output_fn="data/IMP/SuperTrackerDatabase.txt")check.food.db(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt",     addl_foods_fn=NULL, output_tree_fn="output/supertracker.tree.txt",     output_taxonomy_fn = "output/supertracker.taxonomy.txt")
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/IMP/CompleteSuperTrackerDatabase.txt", output_fn="data/IMP/SuperTrackerDatabase.txt")check.food.db(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt",     addl_foods_fn=NULL, output_tree_fn="output/supertracker.tree.txt",     output_taxonomy_fn = "output/supertracker.taxonomy.txt")
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/IMP/CompleteSuperTrackerDatabase.txt", output_fn="data/IMP/SuperTrackerDatabase.txt")check.food.db(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt",     addl_foods_fn=NULL, output_tree_fn="output/supertracker.tree.txt",     output_taxonomy_fn = "output/supertracker.taxonomy.txt")
format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")format.food.db(raw_database_fn="data/MCT/MCTs_study_missing_variables.txt", output_fn="data/MCT/MCTs_study_missing_variables_formatted.txt")format.food.db(raw_database_fn="data/MCT/Soylent_codes.txt", output_fn="data/MCT/Soylent_codes_formatted.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
nodes_fn="data/NodeLabels.txt"; food_database_fn="data/MCT/ASA24Database.txt";    addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"); output_tree_fn="output/mct.tree.txt";    output_taxonomy_fn = "output/mct.taxonomy.txt"
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]    # add additional food codes    lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); main <- rbind(main, new.foods)})#
    flevels <- NULL    for(i in 1:num.levels)        flevels <- cbind(flevels, I(substr(main$FoodID, 1, i)))    colnames(flevels) <- paste0("L",1:num.levels)    main <- data.frame(main, flevels, stringsAsFactors=F)#
    # melt the data, merge to get the node names, then cast back    main.melt <- melt(main, id.vars = "FoodID", variable.name = "Level", value.name = "Level.code")    main.merge <- merge(main.melt, nodes, by = "Level.code")    main.cast <- dcast(main.merge, FoodID ~ Level, value.var = "Main.food.description")    # prepend level to all level descriptions    main.cast[is.na(main.cast)] <- ""    main.cast[,colnames(main.cast)[-1]] <- sapply(colnames(main.cast)[-1], function(colname) paste(colname, main.cast[,colname], sep="_"))    # merge back with original table to grab Food Description    main.join <- merge(main.cast, main[,c("FoodID","Main.food.description")], by="FoodID")    # create a proper newick string for the tree    newickstring <- paste("foodtreeroot", apply(main.join, 1, function(xx) paste(xx[-1], collapse="/")), sep="/")    # create a proper taxonomy string for QIIME    taxonomy <- apply(main.join, 1, function(xx) paste(xx[-1], collapse=";"))    final.table <- data.frame(main.join, newickstring, taxonomy, stringsAsFactors=F)
addl_foods_fn
addl_foods_fn <- data/MCT/Soylent_codes_formatted.txt
addl_foods_fn <- "data/MCT/Soylent_codes_formatted.txt"
lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); main <- rbind(main, new.foods)})
head(main)
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")format.food.db(raw_database_fn="data/MCT/MCTs_study_missing_variables.txt", output_fn="data/MCT/MCTs_study_missing_variables_formatted.txt")format.food.db(raw_database_fn="data/MCT/Soylent_codes.txt", output_fn="data/MCT/Soylent_codes_formatted.txt")
make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]    # add additional food codes    lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); main <- rbind(main, new.foods[,c("FoodID", "Main.food.description")])})
head(main)
main$Main.food.description == "Milk_shake_made_with_skim_milk_chocolate"
which(main$Main.food.description == "Milk_shake_made_with_skim_milk_chocolate")
addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt")
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]    # add additional food codes    l <- lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); main <- rbind(main, new.foods[,c("FoodID", "Main.food.description")])})
which(main$Main.food.description == "Milk_shake_made_with_skim_milk_chocolate")
dim(l)
length(l)
head(l[[1]])
fdata <- read.table(food_database_fn, header = TRUE, sep="\t", colClasses="character", quote="", strip.white=T)    nodes <- read.table(nodes_fn, header = TRUE, sep="\t", colClasses="character")    main <- fdata[,c("FoodID", "Main.food.description")]
dim(main)
l <- lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); main <- rbind(main, new.foods[,c("FoodID", "Main.food.description")])})
dim(main)
l <- lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); print(new.foods); main <- rbind(main, new.foods[,c("FoodID", "Main.food.description")])})
l <- lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); print(new.foods[,c("FoodID", "Main.food.description")]); main <- rbind(main, new.foods[,c("FoodID", "Main.food.description")])})
l <- lapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); return(new.foods[,c("FoodID", "Main.food.description")])})
l
unlist(l)
l
l <- sapply(addl_foods_fn, function(fn) {new.foods <- read.table(fn, header=T, sep="\t", colClasses="character"); return(new.foods[,c("FoodID", "Main.food.description")])})
l
for(i in 0:length(addl_foods_fn)){#
print("test")}
addl_foods_fn <- NULL
for(i in 0:length(addl_foods_fn)){#
print("test")}
i <- 0#
    while(i < length(addl_foods_fn)){#
print("test")}
addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt")
i <- 0#
    while(i < length(addl_foods_fn)){#
print("test")}
i++
;
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")format.food.db(raw_database_fn="data/MCT/MCTs_study_missing_variables.txt", output_fn="data/MCT/MCTs_study_missing_variables_formatted.txt")format.food.db(raw_database_fn="data/MCT/Soylent_codes.txt", output_fn="data/MCT/Soylent_codes_formatted.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
source(paste0(FT_FOLDER,"/lib/newick.tree.r"))source(paste0(FT_FOLDER,"/lib/check.food.db.r"))source(paste0(FT_FOLDER,"/lib/format.food.db.r"))source(paste0(FT_FOLDER,"/lib/make.food.tree.r"))format.food.db(raw_database_fn="data/MCT/MainFoodDesc.txt", output_fn="data/MCT/ASA24Database.txt")format.food.db(raw_database_fn="data/MCT/MCTs_study_missing_variables.txt", output_fn="data/MCT/MCTs_study_missing_variables_formatted.txt")format.food.db(raw_database_fn="data/MCT/Soylent_codes.txt", output_fn="data/MCT/Soylent_codes_formatted.txt")#check.food.db(food_database_fn = "data/MCT/ASA24Database.txt", food_records_fn="data/MCT/dietrecords.txt", output_fn="data/MCT/missing.txt")# if there are missing foods, then create new files to add them in below under addl_foodsmake.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/MCT/ASA24Database.txt",     addl_foods_fn=c("data/MCT/Soylent_codes_formatted.txt","data/MCT/MCTs_study_missing_variables_formatted.txt"), output_tree_fn="output/mct.tree.txt",     output_taxonomy_fn = "output/mct.taxonomy.txt")
format.food.db(raw_database_fn="data/IMP/CompleteSuperTrackerDatabase.txt", output_fn="data/IMP/SuperTrackerDatabase.txt")check.food.db(food_database_fn = "data/IMP/SuperTrackerDatabase.txt", food_records_fn="data/IMP/dietrecords.txt", output_fn="data/IMP/missing.txt")make.food.tree(nodes_fn="data/NodeLabels.txt", food_database_fn="data/IMP/SuperTrackerDatabase.txt",     addl_foods_fn=NULL, output_tree_fn="output/supertracker.tree.txt",     output_taxonomy_fn = "output/supertracker.taxonomy.txt")
