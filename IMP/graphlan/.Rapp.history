a <- (1-eps)^counts    b <- (1 / (3^(counts-1)))    c <- eps^counts    x <- a / (a + b * c)    y <- 1 - x^lengths
y[1]
a[1]
b[1]
c[1]
x[1]
b[1]==0
x <- (1-eps)^counts / ((1-eps)^counts + (1 / (3^(counts-1)))*eps^counts)
x[1]
counts = 11420
a <- (1-eps)^counts    b <- (1 / (3^(counts-1)))    c <- eps^counts    x <- a / (a + b * c)    y <- 1 - x^lengths
a[1]
(1-.05)^15000
(1-.05)^14000
min(double)
double.xmin
.Machine
.Machine$double.xmin
a <- .Machine$double.xmin
a / (a + a*a)
print(a)
1-a^225
a <- NA
is.na(a)
is.null(a)
is.null(NULL)
356563*.05
7/17828.15
1-7/17828.15
?scan
x <- c(3,4,56,3,5,3,3)
unique(x)
library(pwr)
pwr.anova.test(k=2, f=abs(-0.0157416/(2*0.0213438)), power=.8)
pwr.anova.test(k=2, f=abs(-0.0157416/(2*0.095)), power=.8)
pwr.anova.test(k=2, f=abs(-0.1557416/(2*0.01)), power=.8)
pwr.anova.test(k=2, f=abs(0.155/(2*0.0107)), power=.8)
pwr.anova.test(k=2, f=abs(0.03345/(2*0.00928)), power=.8)
pwr.anova.test(k=2, f=abs(0.013/(2*.03)), power=.8)
pwr.anova.test(k=2, f=abs(0.006/(2*.011)), power=.8)
pwr.anova.test(k=2, f=abs(0.005/(2*.009)), power=.8)
pwr.anova.test(k=2, f=abs(0.001/(2*.0002)), power=.8)
x <- (0.7628,0.0147,0.9342,0.1107,0.6797,3.77E-08)
x <- c(0.7628,0.0147,0.9342,0.1107,0.6797,3.77E-08)
apply(p.adjust, x, n=118)
apply(x, 1, p.adjust, n=118)
lapply(x, p.adjust, n=118)
unlist(lapply(x, p.adjust, n=118))
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <- c(0.99027,0.01113,0.4947,0.00593,0.68112,2.00E-16)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <- c(0.762751,0.014663,0.934182,0.110733,0.6797,0.000474)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.99027,0.01113,0.4947,0.00593,0.68112,0.11016)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.0151,0.2543,0.5273,0.1373,0.6461)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.24,0.982,0.711,0.135,0.252)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(00.23701,0.00406,0.5826,0.17664,0.35576)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.7822,0.00425,0.49998,0.00642,0.83877)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.62879,0.24398,0.85792,0.56728,0.17594,0.00197,0.34862)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.595889,0.057916,0.783039,0.699298,0.195882,0.000785,0.905865)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.422,0.103,0.596,0.188,0.281,0.445,0.434)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.859907,0.019876,0.927471,0.210074,0.912991,0.033952,0.000183)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.39105,0.00896,0.56906,0.85463,0.82854,0.00265,0.6415)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.842973,0.191493,0.899186,0.697909,0.624673,0.000883,0.100037)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.6204,0.0262,0.8081,0.2157,0.5274)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.5176,0.0166,0.8463,0.1508,0.3899)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.685,0.0109,0.6065,0.1982,0.3044)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.83045,0.000583,0.629129,0.593527,0.735863)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <-c(0.93858,0.00515,0.83757,0.49479,0.92551)
unlist(lapply(x, p.adjust, n=118, method="fdr"))
x <- rep(0.0147, 119)
p.adjust(x, method="fdr")
x
x <- cbind(c(1,1,1), c(2,2,2))
x
colMeans(x)
x <- cbind(c(1,1,1), c(2,2,2))
x
rownames(x) <- c("a","b","c")
rownames(x)[which(x[,1] %in% c(1,2))]
rownames(x)[x[,1] %in% c(1,2)]
x[,1] %in% c(1,2)
?rank
library(beeswarm)
beeswarm(x=-log10(rep(1:10)), main="Alpha Diversity",#
			ylab="Effect Size", pwpch=rep(23,length(unlist(cols))), pwcol=unlist(cols), pwbg=unlist(cols))#
legend("topright", legend = c("Yes", "No"), pch = pch , col = 1:2)
beeswarm(x=(rep(1:10)), main="Alpha Diversity",#
			ylab="Effect Size", pwpch=rep(23,length(unlist(cols))), pwcol=unlist(cols), pwbg=unlist(cols))#
legend("topright", legend = c("Yes", "No"), pch = pch , col = 1:2)
beeswarm(x=(rep(1:10)), main="Alpha Diversity")
line(1)
abline(h=2)
beeswarm(x=(rep(1:10)), main="Alpha Diversity")
abline(h=2, lty=2)
?wilcox.test
?lm
test <- cbind(1:2,1:2)
rownames(test) <- "#S"
rownames(test) <- c("#S", "1")
test
?abline
x <- 1 > 3
x
x <- 5 > 3
x
class(x)
pwr.anova.test()
library(pwr)
?pwr.anova.test()
pwr.anova.test(2, f=-0.0334525, sig.level=0.05, power=.80)
pwr.anova.test(2, f=0.0334525, sig.level=0.05, power=.80)
pwr.anova.test(2, f=0.1555, sig.level=0.05, power=.80)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.1554/.0107)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.03345/.00928)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=..03/.001)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=..03/.003)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.03/.003)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.007/.001)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.145/.02)
pwr.t.test(sig.level=0.05, power=.80, type="two.sample", d=.001746/.0002)
.03345/.00928
?Sys.geten
?Sys.getenv
library(optparse)
install.packages("optparse")
library(optparse)
?hclust
source("/Users/pvangay/Dropbox/UMN/KnightsLab/IMP/ANALYSES/analysis/bin/load.r")
dm <- wuf_dm[cs,cs] # best to use unifrac hereddm <- as.dist(dm)pc <- cmdscale(ddm,2)map0 <- map[cs,]bd <- betadisper(ddm, map0$Sample.Group)centroid.dist <- bd$distances # distances of all samples to their group centroids!hmong1 <- names(sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 30 & map0$Sample.Group=="Hmong1st"]])[1:15])
use.rare=FALSE
source("/Users/pvangay/Dropbox/UMN/KnightsLab/IMP/ANALYSES/analysis/bin/load.r")
dm <- wuf_dm[cs,cs] # best to use unifrac hereddm <- as.dist(dm)pc <- cmdscale(ddm,2)map0 <- map[cs,]bd <- betadisper(ddm, map0$Sample.Group)centroid.dist <- bd$distances # distances of all samples to their group centroids!hmong1 <- names(sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 30 & map0$Sample.Group=="Hmong1st"]])[1:15])
dm <- wuf_dm[cs,cs] # best to use unifrac hereddm <- as.dist(dm)pc <- cmdscale(ddm,2)map0 <- map[cs,]bd <- betadisper(ddm, map0$Sample.Group)centroid.dist <- bd$distances # distances of all samples to their group centroids!hmong1 <- names(sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 30 & map0$Sample.Group=="Hmong1st"]])[1:20])
hmong1
hmong1 <- names(sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 30 & map0$Sample.Group=="Hmong1st"]])[1:18])
hmong1
o.hmong.1 <- map0[hmong1,c("Age","BMI")]
o.hmong.1
sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 30 & map0$Sample.Group=="Hmong1st"]])[1:18]
bp2 <- plot.b.p.ratio(map0[hmong1,], taxa, bug1=bacteroides, bug2=prevotella, outputfn="hmong1.b.p.ratio.pdf")
getwd()
map0[c("CS.347.0", "CS.164", "CS.228"),c("Age","BMI")]
d <- data.frame(x = pc[,1], y = pc[,2], group=map0$Sample.Group, distance=substring(as.character(centroid.dist[rownames(map0)]),1,4))# set the levels of Sample.Group so that it's the same every timed$group <- factor(d$group, levels=sort(as.character(unique(d$group))))group.cols <- c(alpha(wes_palette(n=5, name="Moonrise3"), .8))p <- ggplot(data=d, aes(x, y)) + geom_point(colour=alpha("gray",.5), size=2) +    scale_color_manual(values=group.cols) + #sets the color palette of the fill    stat_ellipse(data=d, aes(colour=group), show.legend=T, type="t", level=.6)
d <- data.frame(x = pc[,1], y = pc[,2], group=map0$Sample.Group, distance=substring(as.character(centroid.dist[rownames(map0)]),1,4))# set the levels of Sample.Group so that it's the same every timed$group <- factor(d$group, levels=sort(as.character(unique(d$group))))group.cols <- get.group.colors(groups=as.character(levels(d$group)), alpha.val=.8)p <- ggplot(data=d, aes(x, y)) + geom_point(colour=alpha("gray",.5), size=2) +    scale_color_manual(values=group.cols) + #sets the color palette of the fill    stat_ellipse(data=d, aes(colour=group), show.legend=T, type="t", level=.6)
p
p <- p + geom_text(data = d[hmong1, ], aes(label=hmong1) ,hjust=0, vjust=0, size=3)
p
hmongthai <- names(sort(centroid.dist[rownames(map0)[map0$Sample.Group=="HmongThai"]])[1:15])
hmongthai
hmong1 <- names(sort(centroid.dist[rownames(map0)[map0$Sub.Study=="CS" & map0$Years.in.US > 29 & map0$Sample.Group=="Hmong1st"]]))
hmong1
sort(map0[hmong1,"Years.in.US"])
sort(map0[hmong1,"Years.in.US", drop=F])
x <- map0[hmong1,"Years.in.US", drop=F]
x[order(x[,1]),]
x
x[order(x[,1]),,drop=F]
rownames(x[order(x[,1]),,drop=F])[1:5]
maybes <- rownames(x[order(x[,1]),,drop=F])[1:5]
maybes
map0[maybes,c("Age","BMI")]
bp2 <- plot.b.p.ratio(map0[hmong1,], taxa, bug1=bacteroides, bug2=prevotella, outputfn="hmong1.b.p.ratio.pdf")
d <- data.frame(x = pc[,1], y = pc[,2], group=map0$Sample.Group, distance=substring(as.character(centroid.dist[rownames(map0)]),1,4))# set the levels of Sample.Group so that it's the same every timed$group <- factor(d$group, levels=sort(as.character(unique(d$group))))group.cols <- get.group.colors(groups=as.character(levels(d$group)), alpha.val=.8)p <- ggplot(data=d, aes(x, y)) + geom_point(colour=alpha("gray",.5), size=2) +    scale_color_manual(values=group.cols) + #sets the color palette of the fill    stat_ellipse(data=d, aes(colour=group), show.legend=T, type="t", level=.6)# label points by distances#p <- p + geom_text(data = d[hmong1, ], aes(label=distance) ,hjust=0, vjust=0, size=3)# label points by sample namep <- p + geom_text(data = d[hmong1, ], aes(label=hmong1) ,hjust=0, vjust=0, size=3)
p
bp["CS.388",]
bp <- plot.b.p.ratio(map0[cs,], taxa, bug1=bacteroides, bug2=prevotella, outputfn="temp.b.p.ratio.pdf")
bp["CS.388",]
dim(bp)
class(bp)
mybp <- get.taxa.ratio(prevotella,bacteroides)
mybp <- get.taxa.ratio(taxa,prevotella,bacteroides)
mylogbp <- log10(mybp)
mylogbp["CS.388"]
plot(mylogbp[hmong1], map0[hmong1,"Years.in.US"])
plot(map0[hmong1,"Years.in.US"],mylogbp[hmong1])
mybp <- get.taxa.ratio(taxa,bacteroides, prevotella)
mylogbp <- log10(mybp)
plot(map0[hmong1,"Years.in.US"],mylogbp[hmong1])
mylogbp["CS.388"]
mylogbp["CS.135"]
mylogbp["CS.222"]
?pam
sessionInfo()
require(faraway)setwd("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan")source("~/Dropbox/UMN/KnightsLab/IMP/ANALYSES/analysis/lib/utils.r")use.rare=Fsource("~/Dropbox/UMN/KnightsLab/IMP/ANALYSES/analysis/bin/load.r")food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!base.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = gsub(" ", "_", food.taxonomy$Main.food.description), FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)        # let's rescale the average grams of this nutrient consumed in this group by the global min/max so that it's 0-1 for display purposes#         # note that now the average consumption of a nutrient per group, is now scaled for only within that nutrient within that group#         alpha.val <- as.numeric(ring.alpha.df[ring.alpha.df$ring_option=="ring_alpha","ring_option_value"])#         valid.ix <- 1:length(alpha.val)#         if(this.group.name != "Control")#         {#             # let's just set rice to alpha val == 1.0, and remove it from any scaling#             rice.ix <- which(ring.alpha.df$foodname=="Rice_white_cooked_no_salt_or_fat_added_" & ring.alpha.df$ring_option=="ring_alpha")#             valid.ix <- valid.ix[-rice.ix]#         }#         alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values        #         alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value # #         ring.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])#         #         if(this.group.name != "Control") ring.alpha.df[rice.ix, "ring_option_value"] <- "1.0"#                 ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling        rice.ix <- which(final.alpha.df$foodname=="Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
nutrient.names
head(nutrient.group.list[[this.group.name]])
head(nutrients)
head(food.taxonomy)
gsub("L4*", "", food.taxonomy)
head(food.taxonomy)
gsub("L4*", "", "L1_Milk_and_Milk_Products;L2_Milks_and_milk_drinks;L3_Milk_fluid;L4_;Milk_whole")
gsub("L4.+", "", "L1_Milk_and_Milk_Products;L2_Milks_and_milk_drinks;L3_Milk_fluid;L4_;Milk_whole")
gsub(";L4.+", "", "L1_Milk_and_Milk_Products;L2_Milks_and_milk_drinks;L3_Milk_fluid;L4_;Milk_whole")
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$Main.food.description)base.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)        # let's rescale the average grams of this nutrient consumed in this group by the global min/max so that it's 0-1 for display purposes#         # note that now the average consumption of a nutrient per group, is now scaled for only within that nutrient within that group#         alpha.val <- as.numeric(ring.alpha.df[ring.alpha.df$ring_option=="ring_alpha","ring_option_value"])#         valid.ix <- 1:length(alpha.val)#         if(this.group.name != "Control")#         {#             # let's just set rice to alpha val == 1.0, and remove it from any scaling#             rice.ix <- which(ring.alpha.df$foodname=="Rice_white_cooked_no_salt_or_fat_added_" & ring.alpha.df$ring_option=="ring_alpha")#             valid.ix <- valid.ix[-rice.ix]#         }#         alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values        #         alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value # #         ring.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])#         #         if(this.group.name != "Control") ring.alpha.df[rice.ix, "ring_option_value"] <- "1.0"#                 ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling        rice.ix <- which(final.alpha.df$foodname=="Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
warnings()
food.taxonomy$Main.food.description == "Rice_white_cooked_no_salt_or_fat_added_"
which(food.taxonomy$Main.food.description == "Rice_white_cooked_no_salt_or_fat_added_")
food.taxonomy$Main.food.description
which(food.taxonomy$Main.food.description == "Rice white cooked no salt or fat added ")
food.taxonomy[426,]
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$Main.food.description)base.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L1_Grain_Product;L2_Pastas_cooked_cereals_rice;L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
head(final.alpha.df$foodname)
head(base.df)
foodnames
foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy)
foodnames
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy)base.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L1_Grain_Product;L2_Pastas_cooked_cereals_rice;L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
gsub(".+;L3", "L3", "L1_Grain_Product;L2_Pastas_cooked_cereals_rice;L3_Cooked_cereals_rice")
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything aftergsub(".+;L3", "L3", foodnames) #remove everything beforebase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L1_Grain_Product;L2_Pastas_cooked_cereals_rice;L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything afterfoodnames <- gsub(".+;L3", "L3", foodnames) #remove everything beforebase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L1_Grain_Product;L2_Pastas_cooked_cereals_rice;L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,1:2], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$FoodID))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.names# important to use food.taxonomy name so that it matches the tree leaves exactly!# if use lowest level# foodnames <-  gsub(" ", "_", food.taxonomy$Main.food.description)# if use L3foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything afterfoodnames <- gsub(".+;L3", "L3", foodnames) #remove everything beforebase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = foodnames, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]    # aggregate and divide by number of people in this sample group to get average nutrients    grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))        d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)    d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]    nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
head(nutrients)
head(food.taxonomy)
head(nutrients)
food.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything else# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy, by="FoodID", all.x=TRUE)
head(nutrients)
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3){    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before}else{    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,c("FoodID","taxonomy","foodname")], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$foodname))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.namesbase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = food.taxonomy$foodname, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]#
        # aggregate and divide by number of people in this sample group to get average nutrients        grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"foodname"]), function(xx) sum(xx/length(sample.list[[i]])))            d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)        d[d$foodname %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]        nutrient.group.list[[names(sample.list)[i]]] <- d        # aggregate and divide by number of people in this sample group to get average nutrients#         grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))    #         d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)#         d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]#         nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
warnings()
head(final.df)
head(nutrients)
use.L3
head(food.taxonomy)
foodnames
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3){    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before}else{    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3) {    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before}else {    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3) {    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before} else {    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames
# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,c("FoodID","taxonomy","foodname")], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$foodname))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.namesbase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = food.taxonomy$foodname, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]#
        # aggregate and divide by number of people in this sample group to get average nutrients        grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"foodname"]), function(xx) sum(xx/length(sample.list[[i]])))            d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)        d[d$foodname %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]        nutrient.group.list[[names(sample.list)[i]]] <- d        # aggregate and divide by number of people in this sample group to get average nutrients#         grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))    #         d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)#         d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]#         nutrient.group.list[[names(sample.list)[i]]] <- d}# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
dim(this.nutrient.df)
head(d)
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3) {    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before} else {    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,c("FoodID","taxonomy","foodname")], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)# collapse samples into groupsnutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$foodname))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.namesbase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = food.taxonomy$foodname, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]#
        # aggregate and divide by number of people in this sample group to get average nutrients        grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"foodname"]), function(xx) sum(xx/length(sample.list[[i]])))            d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)        d[d$foodname %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]        nutrient.group.list[[names(sample.list)[i]]] <- d        # aggregate and divide by number of people in this sample group to get average nutrients#         grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))    #         d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)#         d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]#         nutrient.group.list[[names(sample.list)[i]]] <- d}
use.L3 = TRUEfood.taxonomy <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/R/output/supertracker.taxonomy.foodsreportedonly.txt", header=T, sep="\t", colClasses="character")nutrients <- read.table("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/generate_meals_nutrients/meals_nutrients.txt", header=T, sep="\t", check.names=F, colClasses="character")colnames(nutrients) <- gsub(" \\(g\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" \\(kcal\\)", "", colnames(nutrients))colnames(nutrients) <- gsub(" ", ".", colnames(nutrients))characterCols <- c("FoodID","Diet.ID","Main.food.description","FoodCode","ModCode")numericCols <- colnames(nutrients)[!(colnames(nutrients) %in% characterCols)]nutrients[,numericCols] <- apply(nutrients[,numericCols], 1:2, as.numeric)nutrient.names <- numericCols[numericCols != "FoodAmt"]nutrient.names <- nutrient.names[nutrient.names != "Energy"] # let's take out Calories for now, too correlated to everything elseif(use.L3) {    foodnames <- gsub(";L4.+", "", food.taxonomy$taxonomy) # remove everything after    foodnames <- gsub(".+;L3", "L3", foodnames) #remove everything before} else {    foodnames <- gsub(" ", "_", food.taxonomy$Main.food.description) # default aggregate is the most descriptive food name}food.taxonomy$foodname <- foodnames# let's merge the food taxonomy with nutrients to get the full taxonomy listnutrients <- merge(nutrients, food.taxonomy[,c("FoodID","taxonomy","foodname")], by="FoodID", all.x=TRUE)# grab cross-sectional IDs onlyHmong2nd <- map_all[hmong_secondgen_cs_all, "Diet.ID"]Hmong1st <- map_all[hmong_firstgen_cs_all, "Diet.ID"]Karen1st <- map_all[karen_firstgen_cs_all, "Diet.ID"]KarenThai <- map_all[karenthai_all, "Diet.ID"]HmongThai <- map_all[hmongthai_all, "Diet.ID"]Control <- map_all[controls_all, "Diet.ID"]sample.list <- list(KarenThai=KarenThai, Karen1st=Karen1st, HmongThai=HmongThai, Hmong1st=Hmong1st, Hmong2nd=Hmong2nd, Control=Control)
nutrient.group.list <- list()nutrients.zero <- matrix(rep(0, length(nutrient.names)*length(unique(nutrients$foodname))), ncol=length(nutrient.names))colnames(nutrients.zero) <- nutrient.namesbase.df <- data.frame(FoodID = food.taxonomy$FoodID, foodname = food.taxonomy$foodname, FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]#
        # aggregate and divide by number of people in this sample group to get average nutrients        grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"foodname"]), function(xx) sum(xx/length(sample.list[[i]])))            d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)        d[d$foodname %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]        nutrient.group.list[[names(sample.list)[i]]] <- d        # aggregate and divide by number of people in this sample group to get average nutrients#         grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))    #         d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)#         d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]#         nutrient.group.list[[names(sample.list)[i]]] <- d}
head(grouped.nurients)
head(grouped.nutrients)
d$foodname
food.taxonomy$foodname
base.df <- data.frame(foodname = unique(food.taxonomy$foodname), FoodAmt=0, nutrients.zero, stringsAsFactors=F)for(i in 1:length(sample.list)){    group.ix <- nutrients$Diet.ID %in% sample.list[[i]]#
        # aggregate and divide by number of people in this sample group to get average nutrients        grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"foodname"]), function(xx) sum(xx/length(sample.list[[i]])))            d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)        d[d$foodname %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]        nutrient.group.list[[names(sample.list)[i]]] <- d        # aggregate and divide by number of people in this sample group to get average nutrients#         grouped.nutrients <- aggregate(nutrients[group.ix, c("FoodAmt", nutrient.names)], list(nutrients[group.ix,"FoodID"]), function(xx) sum(xx/length(sample.list[[i]])))    #         d <- data.frame(base.df, Group=names(sample.list)[i], stringsAsFactors=F)#         d[d$FoodID %in% grouped.nutrients[,1], c("FoodAmt",nutrient.names)] <- grouped.nutrients[, c("FoodAmt",nutrient.names)]#         nutrient.group.list[[names(sample.list)[i]]] <- d}
# color rings by nutrients# cols <- c("#ba1e12", "#FDCF47","#e98000", "#49274a", "#008f95", "#538527")# names(cols) <- nutrient.names # protein red ##ba1e12, fat yellow #FDCF47 , carbs orange #e98000, calories purple #49274a, sugars blue #008f95, fiber green #538527cols <- c("#ba1e12", "#fe6219","#49274a","#008f95", "#1d3c02")names(cols) <- nutrient.names # protein red ##ba1e12, fat orange #fe6219, carbs purple #49274a, sugars blue #008f95, fiber green #1d3c02#
for(i in 1:length(sample.list)) # for each sample group{    final.df <- NULL    this.group.name <- names(sample.list)[i]    this.samples <- sample.list[[this.group.name]]    this.nutrient.df <- nutrient.group.list[[this.group.name]]#
    for(j in 1:length(nutrient.names)) # make a ring for each nutrient    {        this.nutrient.name <- nutrient.names[j]        # use [[ ]] to avoid warnings from name being returned in the cols        ring.color.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_color", ring_level=j, ring_option_value=cols[[this.nutrient.name]], stringsAsFactors=F) #
        ring.alpha.df <- data.frame(foodname=this.nutrient.df$foodname, ring_option="ring_alpha", ring_level=j, ring_option_value=this.nutrient.df[,this.nutrient.name], stringsAsFactors=F)         ring.params <-  data.frame(foodname="",                         ring_option=c("ring_label", "ring_label_color", "ring_external_separator_thickness", "ring_separator_color", "ring_label_font_size"),                         ring_level = j,                         ring_option_value=c(this.nutrient.name, cols[[this.nutrient.name]], "0.5", "#888888", "7"),                         stringsAsFactors=F)#
        final.df <- rbind(final.df, ring.color.df, ring.alpha.df, ring.params)        }    # let's rescale the average grams of this nutrient consumed in this group by min/max of all nutrients consumed so that the gradients in color make more sense    final.alpha.df <- final.df[final.df$ring_option=="ring_alpha",]    alpha.val <- as.numeric(final.alpha.df$ring_option_value)    valid.ix <- 1:length(alpha.val)    if(this.group.name != "Control") # remove RICE from all non-Control groups so the scaling looks a little better    {        # let's just set rice to alpha val == 1.0, and remove it from any scaling#
        rice.ix <- which(final.alpha.df$foodname=="L3_Cooked_cereals_rice") #  "Rice_white_cooked_no_salt_or_fat_added_")        valid.ix <- valid.ix[-rice.ix]    }    alpha.val[valid.ix] <- sqrt(sqrt(alpha.val[valid.ix])) # double sqrt to bring out the low values            alpha.val[valid.ix] <- (alpha.val[valid.ix] - min(alpha.val[valid.ix]))/(max(alpha.val[valid.ix])-min(alpha.val[valid.ix])) # rescale 0-1 for required alpha value     final.alpha.df[valid.ix,"ring_option_value"] <- sprintf("%.3f", alpha.val[valid.ix])    if(this.group.name != "Control") final.alpha.df[rice.ix,"ring_option_value"] <- sprintf("%.3f", 1)#
    final.df[final.df$ring_option=="ring_alpha","ring_option_value"] <- final.alpha.df["ring_option_value"]#
    # specify an even outer ring to show histogram of total average consumption of foods    outer.color.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_color"),                         ring_level = j+1,                         ring_option_value=c("black"),                         stringsAsFactors=F)    food.amt <- this.nutrient.df[,"FoodAmt"]    food.amt <- sqrt(sqrt(food.amt))    food.amt <- (food.amt - min(food.amt))/(max(food.amt)-min(food.amt)) # rescale 0-1    food.amt <- food.amt * 2 # multiply to make it larger    outer.height.df <-  data.frame(foodname=this.nutrient.df$foodname,                         ring_option=c("ring_height"),                         ring_level = j+1,                         ring_option_value=food.amt,                         stringsAsFactors=F)#
    final.df <- rbind(final.df, outer.color.df, outer.height.df)#
    final.df$foodname <- gsub(";", ".", final.df$foodname)#
    outfile <- paste0("~/Dropbox/UMN/KnightsLab/Food_Tree/IMP/graphlan/annotations/", this.group.name, ".annotation.txt")    cat(paste0("title\t", this.group.name, "\n"), file=outfile)    write.table(final.df, outfile, sep="\t", quote=F, row.names=F, col.names=F, append=TRUE)}
